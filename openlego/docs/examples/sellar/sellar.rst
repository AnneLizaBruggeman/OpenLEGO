.. _`sellar_example`:

Sellar Problem Example
======================

This example will demonstrate OpenLEGO's general capabilities and serves as a general proof of concept. In short, this
example uses OpenLEGO to automatically generate an OpenMDAO model and solves it using three different MDAO
architectures:

    1. The MDF architecture with a Gauss-Siedel converger;
    2. The MDF architecture with a Jacobi converger;
    3. The IDF architecture.

The problem was implemented in OpenLEGO by creating subclasses of OpenLEGO's ``AbstractDiscipline`` class for each
discipline that plays a part in the Sellar problem (``D1``, ``D2``, ``F1``, ``G1``, ``G2``). The first discipline,
``D1``, for example, was implemented as follows:

.. literalinclude:: ../../../test_suite/test_examples/sellar/kb/D1.py
   :pyobject: D1

After the Knowledge Base (KB) was populated with these classes, KADMOS was used to set up the problems for the three
different architectures. The XDSM diagrams generated by KADMOS for the MDF architectures and the IDF architecture are
shown here:

+----------------------------------------------------------+----------------------------------------------------------+
|.. figure:: XDSM_MDF.png                                  |.. figure:: XDSM_IDF.png                                  |
|   :width: 95 %                                           |   :width: 95 %                                           |
|   :align: center                                         |   :align: center                                         |
|                                                          |                                                          |
|   XDSM of the Sellar problem using the MDF architecture  |   XDSM of the Sellar problem using the IDF architecture  |
+----------------------------------------------------------+----------------------------------------------------------+

The output of KADMOS that is important for OpenLEGO is a CMDOWS file containing the definition of the problem. This
file, along with the path of the folder the KB is stored in are the only things required to create a corresponding
OpenMDAO representation of the problem.

The following steps are taken in this example to set up the problem using OpenLEGO and then solve it using OpenMDAO:

* First an instance of the OpenMDAO ``Problem`` class is created:

.. literalinclude:: ../../../test_suite/test_examples/sellar/test_sellar.py
   :lines: 33-34

* Next the ``model`` of the problem is created. This is where 'the magic' of OpenLEGO happens. An instance of the
``LEGOModel`` class is created using a given CMDOWS file and KB as inputs.

.. literalinclude:: ../../../test_suite/test_examples/sellar/test_sellar.py
   :lines: 37-40

* The problem and model can then be used as if OpenLEGO had nothing to do with them. That is, they behave like
  a regular OpenMDAO ``Problem`` and ``Group``. To optimize the Sellar problem an appropriate instance of an OpenMDAO
  ``Driver`` class needs to be attached to the problem. For this example the ``ScipyOptimizer`` is used, using the
  SQP algorithm and some settings for displaying the results are added:

.. literalinclude:: ../../../test_suite/test_examples/sellar/test_sellar.py
   :lines: 43-46

* Then the problem is set up and the default settings of the linear and nonlinear solvers of the coupled group of the
  problem are changed. Specifically, the maximum number of iterations of both are increased. This ensures they converge
  when the Jacobi converger is used in an MDF architecture. Next, the model is run once so the variables are
  initialized. Finally, the ``initialize_from_xml`` method exposed by the ``LEGOModel`` class is used to set
  appropriate initial values for the design variables:

.. literalinclude:: ../../../test_suite/test_examples/sellar/test_sellar.py
   :lines: 49-53

* In this example, the ``NormalizedDesignVarPlotter``, ``ConstraintsPlotter``, and ``SimpleObjectivePlotter``
  recorders, included with OpenLEGO, are attached to the driver. These recorders visualize the design vector,
  constraints, and the objective function value as the optimization progresses. The resulting plots are saved as
  image files after the driver finishes:

.. literalinclude:: ../../../test_suite/test_examples/sellar/test_sellar.py
   :lines: 56-70

* The problem is solved like any other OpenMDAO problem:

.. literalinclude:: ../../../test_suite/test_examples/sellar/test_sellar.py
   :lines: 73

* Finally, the values of the design variables, coupling variables, constraints, and the objective function are printed:

.. literalinclude:: ../../../test_suite/test_examples/sellar/test_sellar.py
   :lines: 76-80

* And the problem is cleaned and the ``LEGOModel``'s cache is invalided:

.. literalinclude:: ../../../test_suite/test_examples/sellar/test_sellar.py
   :lines: 83-84
